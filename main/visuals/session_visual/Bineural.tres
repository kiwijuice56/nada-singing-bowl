[gd_resource type="Shader" format=3 uid="uid://d4sj0yuhk40x"]

[resource]
code = "shader_type canvas_item;

uniform vec2 uv_offset;
uniform float time = 0.0;
uniform float aspect_ratio = 1.0;
uniform float color_intensity = 1.0;
uniform float scale = 1.0;
uniform float border = 0.1;
uniform float audio1 = 0.0;

vec2 sinusoidal(vec2 c, float offset) {
	c.x = sin(c.x + offset);
	c.y = sin(c.y + offset);
	return c;
}

vec2 spherical(vec2 c, float offset) {
	vec2 t = c;
	c.x = c.x / (c.x * c.x + c.y * c.y) + offset;
	c.y = c.y / (t.x * t.x + t.y * t.y) + offset;
	return c;
}

vec2 julia(vec2 c, vec2 p) {
	int i = 0;
	for (; i < 16; i++) {
		if (c.x * c.x + c.y * c.y > 4.0) {
			break;
		}
		float t = c.x * c.x - c.y * c.y + p.x;
		c.y = 2.0 * c.x * c.y + p.y;
		c.x = t;
	}
	
	float modulus = sqrt(c.x * c.x + c.y * c.y);
	float mu = max(0, (float(i) - log(log(modulus)) / log(2.0))) / 16.0;
	
	return c * vec2(mu);
}

vec3 hsv2rgb(vec3 c)
{
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

void fragment() {
	vec2 c = UV;
	
	if (UV.y < border) {
		COLOR.a = c.y / border;
	}
	
	// Setup the coordinate system.
	c += uv_offset; 
	c -= vec2(0.5, 0.5);
	c *= scale;
	c.x *= aspect_ratio;
	
	// Apply functions randomly.
	c = sinusoidal(c, 0.0);
	c = spherical(c, time);
	c = sinusoidal(c, time);
	c = spherical(c, time);
	c = julia(c, c);
	
	// Turn the final coordinate into a color.
	COLOR.rgb = hsv2rgb(vec3(1.4 + c.y * 0.6, 0.5, c.x)) * sqrt(color_intensity);
	COLOR.r -= UV.x * color_intensity * time * 0.5;
}
"
metadata/_edit_res_path = "res://main/visuals/JuliaFractal.tres"
